#pragma once
#include <brick-assert>
#include <brick-string>
#include <brick-enumerate>

namespace brq
{
    struct precondition_failed : std::exception {};

    void precondition( bool x )
    {
        if ( !x )
            throw precondition_failed{};
    }

    template< typename out_t, typename... state_t >
    struct program
    {
        using op_t = std::function< out_t( state_t & ... ) >;
        using outs_t = std::vector< out_t >;

        std::vector< op_t > ops;
        brq::string_builder str;

        friend brq::string_builder &operator<<( brq::string_builder &b, const program &p )
        {
            return b << p.str;
        }

        auto eval( state_t... state )
        {
            using outs_t = std::vector< out_t >;
            outs_t outs;

            for ( auto &f : ops )
                outs.push_back( f( state... ) );

            return std::tuple< outs_t, state_t... >{ outs, state... };
        }

        void add( const op_t &op, std::string_view name )
        {
            ops.push_back( op );
            str << "\n" << name;
        }
    };

    template< typename out_t, typename... state_t >
    auto enum_program( brq::nat index,
                       std::vector< std::string_view > names,
                       auto... avail )
    {
        using op_t = std::function< out_t( state_t & ... ) >;
        using ops_t = std::vector< op_t >;

        ops_t avail_vec{ avail... };
        program< out_t, state_t ... > p;

        for ( auto i : brq::enumerate::list( index, avail_vec.size() ) )
            p.add( avail_vec[ i.short_digit() ], names[ i.short_digit() ] );

        return p;
    }

    template< typename out_t, typename... state_t >
    auto enum_program( brq::nat index, auto... avail )
    {
        using op_t = std::function< out_t( state_t & ... ) >;
        using ops_t = std::vector< op_t >;

        std::vector< std::string_view > names{ std::get< 0 >( avail )... };
        ops_t avail_vec{ std::get< 1 >( avail )... };
        program< out_t, state_t ... > p;

        for ( auto i : brq::enumerate::list( index, avail_vec.size() ) )
            p.add( avail_vec[ i.short_digit() ], names[ i.short_digit() ] );

        return p;
    }

    template< typename... args_t >
    struct fcmp_input
    {
        std::tuple< args_t... > args;
    };

    std::type_index except_type( std::exception_ptr eptr )
    {
        try
        {
            if ( eptr )
                std::rethrow_exception( eptr );
        }
        catch ( const std::exception &e )
        {
            return typeid( e );
        }

        return typeid( nullptr );
    }

    bool except_type_eq( std::exception_ptr a_ptr, std::exception_ptr b_ptr )
    {
        if ( !a_ptr && !b_ptr )
            return true;
        if ( !a_ptr || !b_ptr )
            return false;

        return except_type( a_ptr ) == except_type( b_ptr );
    }

    struct fcmp_base
    {
        virtual bool is_match() const = 0;
        explicit operator bool() const { return is_match(); }
    };

    template< typename retval_t, typename... args_t >
    struct fcmp_result : fcmp_base
    {
        fcmp_input< args_t... > input;
        std::tuple< args_t... > f_args, g_args;
        retval_t f_retval, g_retval;
        std::optional< int > timeout;
        std::exception_ptr f_except, g_except;

        bool is_match() const override
        {
            return f_args == g_args &&
                   f_retval == g_retval &&
                   !timeout.has_value() &&
                   except_type_eq( f_except, g_except );
        }

        friend brq::string_builder &operator<<( brq::string_builder &b, const fcmp_result &r )
        {
            b << "\n";
            b << "input arguments: " << r.input.args << "\n";

            if ( r.f_args != r.g_args )
            {
                b << "output arguments:\n"
                  << "  expected: " << r.f_args << "\n"
                  << "  actual: " << r.g_args << "\n";
            }

            if ( r.f_retval != r.g_retval )
            {
                b << "return value:\n"
                  << "  expected: " << r.f_retval << "\n"
                  << "  actual: " << r.g_retval << "\n";
            }

            auto f_eid = except_type( r.f_except );
            auto g_eid = except_type( r.g_except );

            if ( f_eid != g_eid )
            {
                b << "exception type:\n"
                  << "  expected: " << f_eid.name() << "\n"
                  << "  actual: " << g_eid.name() << "\n";
            }

            return b;
        }
    };

    auto fcmp_call( auto fun, auto &arg, auto &rv, auto &eptr )
    {
        try
        {
            rv = std::apply( fun, arg );
        }
        catch ( ... )
        {
            eptr = std::current_exception();
        }
    }

    auto fcmp( auto f, auto g, auto... args )
    {
        fcmp_result< decltype( g( args... ) ), decltype( args )... > r;

        r.f_args = r.g_args = r.input.args = std::tuple{ args... };
        TRACE( r.input.args );
        fcmp_call( f, r.f_args, r.f_retval, r.f_except );
        fcmp_call( g, r.g_args, r.g_retval, r.g_except );
        brq::trace_clear();

        return r;
    }

    void fcmp_assert( auto f, auto g, auto && ... args )
    {
        auto match = fcmp( f, g, std::forward< decltype( args ) >( args )... );
        ASSERT( match );
    }
}
